---
title: It Takes a Village to Raise a Programmer, Part 1
subtitle: In Which a Philosophy Major Attempts to Justify His Decisions
category: programming
---
I remember getting into a conversation with someone who was auditing a class I was taking during my last quarter in college about job prospects for people with philosophy degrees. It was a graduate-level course and he was — if I’m recalling this correctly — considering a Ph.D. at the college I was just about to get a bachelor’s degree from.<!-- more --> “If you know a little bit of statistics and a programming language, you’re pretty much set, job-wise,” he told me, mentioning that a lot of philosophy majors end up as computer programmers. That’s something I heard quite a bit among my peers in the philosophy program, in that same nervous conversation that happened at least once a week — even more frequently as the end of the school year started to come around. The options seemed pretty slim: law school, grad school, or computer programming. I was disgusted by the idea of the first, and wanted to wait before committing to the second. Was the third my only other choice?

Another conversation with a professor went in a similar direction. I really enjoyed the logic classes I was taking, and wanted to know I could take that information beyond undergrad. He suggested computer science, mentioning that the field was where most logicians were ending up these days. “I know plenty of philosophy alumni that are now in tech.”

This was a bit frustrating, since at the time I was still pretty solid on my choice to swear off writing any more code after I swapped majors from computer science during my freshman year of college. The thought of going back on that promise to myself wasn’t even on my radar at this point. Truth be told, my reasons for making that decision were obscure to me by then, but it was somehow enough to keep the thought of re-learning a programming language from crossing my mind for years. It was like a vestigial habit or anti-ritual that was at this point so far removed from its original meaning or purpose that it’s almost surprising that Richard Dawkins hadn’t written a book about it by then. Nevertheless, programming persisted as a non-option for me, even when the fact that I would really have to actually find a job — a real, honest-to-goodness Grown-Up Job — very soon was looming over me, staring me right in the eyeballs.

What was a guy — a lone, young, soon-to-be-entering-the-real-world philosophy major guy — to do? The first time I ever Googled something like “philosophy major jobs” was during the last few weeks of my last term in college, which is surely much later than any counselor would advise, but so it goes. The results were a 50–50 split between the stock “Here’s What You Can Do With A Philosophy Degree” lists on various department websites, and articles talking about how you’ll find a philosophy major working literally every imaginable kind of job. The former would basically beg you to go to grad school or law school or get into politics (med school also appeared quite a bit), and the latter also came with about a hundred implied asterisks singing the tune of “But Also Go To Grad School.”

Sure, grad school is a great option for me. Statistically speaking, I’m bound for a higher GRE score than any other humanities major, and I received decent marks during my undergraduate home stretch. Up until my last year, my elevator speech about future plans even included the words “grad school,” and I’m not saying I won’t wind up there at some point. But here’s the thing: student loans don’t go away even if you spend the rest of your life in lecture halls and seminars, and (more importantly to me) I have another person in my life that I have to keep in mind with my life decisions. Grad school was, and still is, something that’s on the horizon for me, but I was fit for a change the day I dragged my battered self across the stage at commencement.

Here’s a weird activity for you to try. Send a resume to a company in response to a job ad, and follow this rule: there must be zero bullet points in common between the listed duties/qualifications listed on the ad and your resume. In your cover letter, type up a paragraph arguing just how your bullet points are logically tied to their bullet points, and another paragraph with claims about the clinical benefits of hiring someone with a degree that isn’t listed in the job ad. Repeat twenty-seven times.

I’ll omit some verbiage re: generational angst and ‘useful’ college majors.

Don’t get me wrong. I’ve never expected to be able to just walk into a job in an industry to which I’ve never had any exposure solely by my merits in my undergraduate philosophy program. I’ve always known that I would need to start small, but I reserve my right to feel frustrated.

Here’s my point: it’s tough out there. Jobs aren’t quite yet at the point where they’re literally growing from trees and available in the produce aisle all year, and if you decided to go for one of the more esoteric majors in college, you’ve got some work to do. However, I’m willing to wager that most philosophy majors are plenty happy with their decision, and I consider myself among that majority. Here’s why (and feel free to use this in a job interview if you think it sounds neat): philosophy (and the humanities in general) is not only something you decide to study in undergrad despite your parents’ best wishes. It’s a ticket to keep learning things for the rest of your life. It’s a catalyst for curiosity that stretches beyond your Kants and your Platos and your Wittgensteins. It provides both adequate exposure to all sorts of fields, as well as the tools to take on those fields independently and critically, with the only question being that of which route to take.

For me, that route ended up being programming, but not after a lot of mental toil. Getting into the practice meant going full circle for me. It meant admitting I was wrong about leaving it in the first place, and to some it might make these past few years of college look like a waste. After all, I think I was pretty good at it back in the day, and if I could remember my reasons for walking away from it, I’d probably consider them petty or immature.

Perhaps that’s what it took, though. Perhaps it took several years of swapping between majors (something I did a lot of) and figuring out exactly how I wanted to think about my future career choices to come to this point. Had I stayed on the straight and narrow, I don’t think my heart would’ve been in it for very long. Being a bit of a late bloomer, it takes me a period of grappling with something before I decide to accept it, and my college experience represented exactly that.

Why programming, then? Among the hundreds of other skills I could’ve picked up, why choose the one about which I was the most conflicted? I’m not sure if I have a good answer for that yet, but I think part of the answer involves my future academic pursuits. Here’s a hint at what I mean: when I began playing around with code last summer, I was pleased to feel the same parts of my brain I had exercised going through my philosophy program were being put to use. That shouldn’t be too surprising, considering that most of my efforts in philosophy were related to logic, and computers are built from exactly that (Turing was as much a logician as he was a computer scientist — the two terms might as well have meant the same thing. I even recall building Turing machines in a philosophy class I took in college). If something is wrong with a computer program, it’s a logical issue that can be traced the same way a rotten argument can be followed. The same itch that occurs when something doesn’t feel quite right about a work in philosophy is there when a bug pops up. Necessary conditions and sufficient conditions and all that.

I’d probably be lying, too, if I were to say that money wasn’t one of the major motivating factors for me in deciding to go back to programming. The average salary for a programmer is pretty high for even the most basic entry-level positions, and it’s increasing very quickly. I was very into the idea of aggressively paying down my student loans so I could get on with my life, and tech was the industry in which this was most likely to happen as soon as possible. There’s also a lot of talk about a more tolerable work culture in the tech industry, with forward-thinking employers and perks and stellar work-life balance.

Accessibility is another thing. There are hundreds of people on the internet right now who are begging to teach you something about programming. I’ll get to that in part 2.

Part 2 will begin discuss the process of actually beginning to learn the trade, but I want to end this part with some thoughts about taking a job that (at least at the surface) doesn’t really have a whole lot to do with what you studied in college. There is some bitterness among a lot of my friends and peers about how they’re not actually ‘using’ anything they learned in college. This always struck me as strange, since college never really seemed to serve that purpose. To be sure, you’d probably expect to become an engineer if you get an engineering degree, but the career path for someone outside STEM is somewhat less cut and dry. Most humanities majors probably enter a professional world in which nobody cares about which books they read in college, and that seems to hurt some people.

I’ve written about this in plenty of other spaces, but here’s another space in which it’s probably appropriate: as I said above, a college degree is a ticket to a lifetime of learning. An education enriches your perspective and provides you with the tools to engage with the world with a critical mind. While your career may not involve the things about which you loved learning in college, but the ways in which you navigate the professional world are absolutely influenced by those things. An awareness of this fact, I think, is the first step in resolving the pragmatic angst of not ‘using’ your college education.
